Closing a channel indicates that no more values will be sent on it. This can be useful to communicate completion to the channel's receivers

each context.Context should represent for only one data query, not for an entire database object

Page 27:
i++
If your context is a goroutine that doesn't expose i to other goroutines, then this code is atomic.

Page 158: 
Golang doesn't have throw/catch mechanic so you need to build a struct if you want to keep track of possible errors:
type Result struct {
    Error    error
    Response interface{} //change this one
}

Page 162:
Pipeline is nothing too amazing tbh. It's just a bunch of functions return the same type of value, so the function can be "recycled" or "called" by another function 
as variable including itself. One easy example: fibonacci without recursive. 2 types: stream process and batch process

Batch process: 
The function returns a batch, an array of values. Increase scalability, though it will eat up more memory initially, but it makes your works a lot more easier 
later on. (Because everything the function is triggered, it will load the entire *batch* that you just pass into them)

Stream process:
The function returns a single individual, it will greatly reduce the memory required (well, most of the time). But it will render the scalability. 
Not recommended tbh.

Page 169-170 is important.

interface{} is not any type. It will be downcast to the first type that it's assigned to.
A pointer type can access the methods of its associated value type, but not vice versa
(d Dog)doSomething() int {} => (*aDog).doSomething(); OK
(d *Dog)doSomething() int {} => aDog.doSomething(); FAIL
You can use doSomething(a ...interface{}) (1) but you should not use doSomething(a []interface{}) (2) because 
the code can run properly in (1) (if you write doSomething(a int, b string, c bool)) but
the code will return a compile warning in (2) (if you write doSomething( a []int)) Gotta convert everything of that a to interface first
    vals := make([]interface{}, len(names))
	for i, v := range names {
	    vals[i] = v
    }

Why is it not recommended to use {}interface?

In generators, it's fine to use generic indicator (the chan interface{}). Though, you can double the speed with specific indicator (like chan int or chan string) 
but the difference is negligible.

Fan-out is a term to describe the process of starting multiple goroutines to handle input from the pipeline, and fan-in is a term to describe the process of
combining multiple results into one channel. Use fanning if both of this requirements are met:
One of the stages in your pipeline doesnâ€™t rely on values that the stage had calculated before.
And it takes a long time to run.

Fan-in is like a double-edge knife. Could speed up the process but still might cause unpleasant experience because it takes over all cores of the CPU which means
it will lower other applications quality which is not a good thing. (Try playing hots on a toaster and you'll see). Nothing is free, it's just a trade-off.

So to prevent goroutine leak, you do this in every goroutine: 
instead of:
    for val := range myChan (might leak goroutine) 
TO
    go func() {             (no more leaking)
        for{
            select {
            case <-done:
                return
            case maybeVal, ok := <- myChan: 
                ... 
            }
        }
    }

^ this could get worse if ... is a nested loop because you'll need to "case <-done" again and again. This is like callback hell in js. So we could combine 
or-channel technique to handle this mess. (Like how js has Promise for the callback hell).
Solution:
go func() {
    defer close(valStream)
    for {
        select {
        case <- done: return
        case v, ok := <- valStream:
            if ok == false {
                return
            }
            select {            (cleaner)
            case valStream <- v:
            case <-done:                
            }
        }
    }
}()

and then you just need to do for val := range or_done(done, thatChannelYouWantToTraverseWithoutLeaking)

tee channel... it splits a channel to multiple channels. (the origin doesn't change though)

a lil difference between fan-in and or-channel
fan-in = all the elements that other channels contain

or-channel = all the SIGNAL that other channels contain and SHARE THAT SIGNAL to every channel that is link to the or-channel.

so when channel1 is closed, every channel that is linked to the or-channel as well as the or-channel will be closed, but the fan-in channel won't be.

Can't see much use of bridge channel. If you want to a stream around,
EX: chanStream <- stream. Remember to close stream first, otherwise they