each context.Context should represent for only one data query, not for an entire database object

Page 27:
i++
If your context is a goroutine that doesn't expose i to other goroutines, then this code is atomic.

Page 158: 
Golang doesn't have throw/catch mechanic so you need to build a struct if you want to keep track of possible errors:
type Result struct {
    Error    error
    Response interface{} //change this one
}

Page 162:
Pipeline is nothing too amazing tbh. It's just a bunch of functions return the same type of value, so the function can be "recycled" or "called" by another function 
as variable including itself. One easy example: fibonacci without recursive. 2 types: stream process and batch process

Batch process: 
The function returns a batch, an array of values. Increase scalability, though it will eat up more memory initially, but it makes your works a lot more easier 
later on. (Because everything the function is triggered, it will load the entire *batch* that you just pass into them)

Stream process:
The function returns a single individual, it will greatly reduce the memory required (well, most of the time). But it will render the scalability. 
Not recommended tbh.

Multiple functions can read from the same channel until that channel is closed; this is called fan-out.
A function can read from multiple inputs and proceed until all are closed by multiplexing the input channels onto a single channel that's closed when 
all the inputs are closed. This is called fan-in.

Page 169-170 is important.

interface{} is not any type. It will be downcast to the first type that it's assigned to.
A pointer type can access the methods of its associated value type, but not vice versa
(d Dog)doSomething() int {} => (*aDog).doSomething(); OK
(d *Dog)doSomething() int {} => aDog.doSomething(); FAIL
You can use doSomething(a ...interface{}) (1) but you should not use doSomething(a []interface{}) (2) because 
the code can run properly in (1) (if you write doSomething(a int, b string, c bool)) but
the code will return a compile warning in (2) (if you write doSomething( a []int)) Gotta convert everything of that a to interface first
    vals := make([]interface{}, len(names))
	for i, v := range names {
	    vals[i] = v
    }