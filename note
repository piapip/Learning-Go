each context.Context should represent for only one data query, not for an entire database object

Page 27:
i++
If your context is a goroutine that doesn't expose i to other goroutines, then this code is atomic.

Page 158: 
Golang doesn't have throw/catch mechanic so you need to build a struct if you want to keep track of possible errors:
type Result struct {
    Error    error
    Response interface{} //change this one
}

Page 162:
Pipeline is nothing too amazing tbh. It's just a bunch of functions return the same type of value, so the function can be "recycled" or "called" by another function 
as variable including itself. One easy example: fibonacci without recursive. 2 types: stream process and batch process

Batch process: 
The function returns a batch, an array of values. Increase scalability, though it will eat up more memory initially, but it makes your works a lot more easier 
later on. (Because everything the function is triggered, it will load the entire *batch* that you just pass into them)

Stream process:
The function returns a single individual, it will greatly reduce the memory required (well, most of the time). But it will render the scalability. 
Not recommended tbh.

Page 169-170 is important.

interface{} is not any type. It will be downcast to the first type that it's assigned to.
A pointer type can access the methods of its associated value type, but not vice versa
(d Dog)doSomething() int {} => (*aDog).doSomething(); OK
(d *Dog)doSomething() int {} => aDog.doSomething(); FAIL
You can use doSomething(a ...interface{}) (1) but you should not use doSomething(a []interface{}) (2) because 
the code can run properly in (1) (if you write doSomething(a int, b string, c bool)) but
the code will return a compile warning in (2) (if you write doSomething( a []int)) Gotta convert everything of that a to interface first
    vals := make([]interface{}, len(names))
	for i, v := range names {
	    vals[i] = v
    }

Why is it not recommended to use {}interface?

In generators, it's fine to use generic indicator (the chan interface{}). Though, you can double the speed with specific indicator (like chan int or chan string) 
but the difference is negligible.

Fan-out is a term to describe the process of starting multiple goroutines to handle input from the pipeline, and fan-in is a term to describe the process of
combining multiple results into one channel. Use fanning if both of this requirements are met:
One of the stages in your pipeline doesnâ€™t rely on values that the stage had calculated before.
And it takes a long time to run.